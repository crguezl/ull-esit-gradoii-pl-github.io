<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.21.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Análisis Sintáctico Predictivo Recursivo - PL</title>
<meta name="description" content="Itinerario de Computación. 2º cuatrimestre">


  <meta name="author" content=" Casiano Rodríguez León">
  


<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="PL">
<meta property="og:title" content="Análisis Sintáctico Predictivo Recursivo">
<meta property="og:url" content="http://0.0.0.0:4000/assets/temas/syntax-analysis/analisis-descendente-predictivo-recursivo/pdr-teoria.html">


  <meta property="og:description" content="Itinerario de Computación. 2º cuatrimestre">











  

  


<link rel="canonical" href="http://0.0.0.0:4000/assets/temas/syntax-analysis/analisis-descendente-predictivo-recursivo/pdr-teoria.html">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Procesadores de Lenguajes",
      "url": "http://0.0.0.0:4000/"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="PL Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use :/https/realfavicongenerator.net/ -->

<meta http-equiv="Content-Security-Policy" content="img-src * 'self' data: https:">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

      

  

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/escuela-politecnica-ingenieria-original.png" alt=""></a>
        
        <a class="site-title" href="/">
          PL
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/clases">Clases</a>
            </li><li class="masthead__menu-item">
              <a href="/temas">Temas</a>
            </li><li class="masthead__menu-item">
              <a href="/practicas">Labs</a>
            </li><li class="masthead__menu-item">
              <a href="/resources">Recursos</a>
            </li><li class="masthead__menu-item">
              <a href="/timetables">Horarios</a>
            </li><li class="masthead__menu-item">
              <a href="/references">Referencias</a>
            </li><li class="masthead__menu-item">
              <a href="/search">Search</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  
  
    
      
      
      
      
    
      
      
      
      
    
    
      

<nav class="nav__list">
  <h3 class="nav__title" style="padding-left: 0;"></h3>
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle menu</label>
  <ul class="nav__items">
    
      <li>
        
          <span class="nav__sub-title">GITHUB</span>
        

        
        <ul>
          
            <li><a href="https://github.com/ULL-ESIT-PL-2122" target="_blank">Organization</a></li>
          
            <li><a href="https://classroom.github.com/classrooms/90842648-ull-esit-pl-2122" target="_blank">Classroom</a></li>
          
            <li><a href="https://github.com/ULL-ESIT-GRADOII-PL/ull-esit-gradoii-pl.github.io" target="_blank">Apuntes repo</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">CAMPUS VIRTUAL</span>
        

        
        <ul>
          
            <li><a href="https://campusingenieriaytecnologia2122.ull.es/course/view.php?id=2122090039" target="_blank">PL en el Campus Virtual</a></li>
          
            <li><a href="https://campusingenieriaytecnologia2122.ull.es/mod/forum/index.php?id=2122090039" target="_blank">Foros</a></li>
          
            <li><a href="https://campusingenieriaytecnologia2122.ull.es/mod/assign/index.php?id=2122090039" target="_blank">Tareas</a></li>
          
            <li><a href="https://www.ull.es/apps/guias/guias/view_guide_course/2122/139263121" target="_blank">Guia Docente</a></li>
          
            <li><a href="https://www.ull.es/apps/guias/guias/view_guide_course/2122/139263121/3/" target="_blank">Horario de Tutorías</a></li>
          
            <li><a href="https://www.ull.es/grados/ingenieria-informatica/informacion-academica/horarios-y-calendario-examenes/#tercero" target="_blank">Horarios Tercero</a></li>
          
            <li><a href="https://www.ull.es/servicios/biblioteca/servicios/puntoq/" target="_blank">BULL PuntoQ</a></li>
          
            <li><a href="https://www.ull.es/estudios-docencia/calendario-academico/" target="_blank">Calendario Académico</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">GOOGLE</span>
        

        
        <ul>
          
            <li><a href="https://meet.google.com/eha-yfij-zmo" target="_blank">Meet</a></li>
          
            <li><a href="https://youtube.com/playlist?list=PLuPGCp-dfrUTzN_o2beArY1QoFUTGH-yd" target="_blank">Videos</a></li>
          
            <li><a href="https://chat.google.com/u/1/" target="_blank">Chat</a></li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>

    
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Análisis Sintáctico Predictivo Recursivo">
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Análisis Sintáctico Predictivo Recursivo
</h1>
          


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-list"></i> Tabla de Contenidos</h4></header>
              <ul class="toc__menu" id="pltoc"><li><a href="#subsection:introduccion">Introducción A los Analizadores Sintácticos</a></li><li><a href="#gramaticas">Gramáticas Independientes del Contexto</a><ul><li><a href="#clase-de-pl-20200413-la-gramática-de-egg">Clase de PL 2020/04/13: La Gramática de Egg</a></li><li><a href="#ejercicio">Ejercicio</a></li></ul></li><li><a href="#lenguaje">Lenguaje Generado por Una Gramática</a></li><li><a href="#funpervar">Una función por Variable Sintáctica</a></li><li><a href="#lookahead">El Token de Predicción</a></li><li><a href="#calculando-por-donde-empiezan-las-derivaciones">Calculando por donde empiezan las derivaciones</a></li><li><a href="#first">Los Conjuntos FIRST</a></li><li><a href="#pseudocódigo-de-la-función-de-parsing">Pseudocódigo de la Función de Parsing</a></li><li><a href="#que-hacer-cuando-aparecen-reglas-vacías">Que hacer cuando aparecen reglas vacías</a></li><li><a href="#cálculo-del-follow">Cálculo del FOLLOW</a></li></ul>

            </nav>
          </aside>
        
        <h2 id="subsection:introduccion">Introducción A los Analizadores Sintácticos</h2>

<p>Después de la fase de análisis léxico la siguiente fase en la construcción del analizador es la fase de
análisis sintáctico. Esta toma como entrada el flujo de terminales y
construye como salida el <a href="ast-description">árbol de análisis sintáctico abstracto</a>.</p>

<p>Existen diferentes métodos de análisis sintáctico. La mayoría caen en
una de dos categorías:</p>

<ol>
  <li>ascendentes y</li>
  <li>descendentes.</li>
</ol>

<p>Los ascendentes
construyen el árbol desde las hojas hacia la raíz.</p>

<p>Los descendentes lo
hacen en modo inverso.</p>

<p>El que describiremos aquí es un descendente: se denomina <strong>método de análisis predictivo descendente recursivo</strong>.</p>

<h2 id="gramaticas">Gramáticas Independientes del Contexto</h2>

<p>Supongamos una gramática \(G = (\Sigma, V, P, S)\) con alfabeto \(\Sigma\), conjunto de variables sintácticas (o no terminales) \(V\), reglas de producción \(P\) y símbolo de arranque \(S\).</p>

<p>Por ejemplo, en la gramática de Egg este es el conjunto \(P\) de reglas de producción:</p>

<pre><code class="language-yacc">expression: STRING
          | NUMBER
          | WORD apply

apply: /* vacio */
     | '(' (expression ',')* expression? ')' apply
</code></pre>

<p>Sólo hay dos variables sintácticas \(V = \{ expression, \, apply \}\). El símbolo de arranque \(S\) es \(expression\).</p>

<p>El conjunto de tokens es:</p>

\[\Sigma = \{ STRING,\, NUMBER,\, WORD,\, '(',\, ')',\, ','  \}\]

<p>Observe que algunos de los tokens son a su vez lenguajes de cierta complejidad, cuya definición está en otro nivel de abstracción, <strong>el nivel léxico</strong> y que se pueden definir mediante un mecanismo 
mas secillo como son las expresiones regulares.</p>

<p>Por ejemplo, en una definición de Egg inicial podríamos definir así lo que entendemos por <strong>espacios</strong> o <strong>blancos</strong>, esto es, que partes del texto no son significativas para que nuestro programa pueda entender la estructura de la frase:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">WHITES</span> <span class="o">=</span> <span class="sr">/</span><span class="se">(\s</span><span class="sr">|</span><span class="se">[</span><span class="sr">#;</span><span class="se">]</span><span class="sr">.*|</span><span class="se">\/\*(</span><span class="sr">.|</span><span class="se">\n)</span><span class="sr">*</span><span class="se">?\*\/)</span><span class="sr">*/</span>
</code></pre></div></div>

<p>así como los tokens mas complejos:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">STRING</span> <span class="o">=</span> <span class="sr">/"</span><span class="se">((?:[^</span><span class="sr">"</span><span class="se">\\]</span><span class="sr">|</span><span class="se">\\</span><span class="sr">.</span><span class="se">)</span><span class="sr">*</span><span class="se">)</span><span class="sr">"/</span>
<span class="nx">NUMBER</span> <span class="o">=</span> <span class="sr">/</span><span class="se">([</span><span class="sr">-+</span><span class="se">]?\d</span><span class="sr">*</span><span class="se">\.?\d</span><span class="sr">+</span><span class="se">([</span><span class="sr">eE</span><span class="se">][</span><span class="sr">-+</span><span class="se">]?\d</span><span class="sr">+</span><span class="se">)?)</span><span class="sr">/</span>
<span class="nx">WORD</span>   <span class="o">=</span> <span class="sr">/</span><span class="se">([^\s</span><span class="sr">(),"</span><span class="se">]</span><span class="sr">+</span><span class="se">)</span><span class="sr">/</span>
</code></pre></div></div>

<h3 id="clase-de-pl-20200413-la-gramática-de-egg">Clase de PL 2020/04/13: La Gramática de Egg</h3>

<!-- Courtesy of embedresponsively.com //-->

<div class="responsive-video-container">
    <iframe src="https://www.youtube-nocookie.com/embed/0Xk_r8V_FeE" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe>
  </div>

<h3 id="ejercicio">Ejercicio</h3>

<p>Construye una derivación para la frase</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print(**(g,f)(8))
</code></pre></div></div>

<p>Observa que el resultado del análisis léxico sería un stream como este:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WORD["print"] "(" WORD[**] "(" WORD[g] "," WORD[f] ")" "(" NUMBER[8] ")" ")"
</code></pre></div></div>

<p><strong>Solución</strong>:</p>

<p>En la solución que sigue, 
abreviamos <em>expression</em> por \(e\) , 
<em>apply</em> por \(a\),
 <em>WORD</em> por \(W\) y <em>NUMBER</em> por \(N\):</p>

<p>\(e \Longrightarrow  W [print] a\) (Aquí \(e \longrightarrow W a\))</p>

<p>\(\Longrightarrow W[print] (e) a\) (Ya que \(a \longrightarrow  (e) a\))</p>

<p>\(\Longrightarrow  W [print] (e)\) (Ya que  \(a \longrightarrow \epsilon\))</p>

<p>\(\Longrightarrow W[print] (W[**] a)\) (Aquí hizo \(e \longrightarrow W a\))</p>

<p>\(\Longrightarrow W[print] (W[**] (e, e) a )\)  (Aquí hizo \(a \longrightarrow (e, e) a\))</p>

<p>\(\Longrightarrow W[print] (W[**] (e, e) (e) a )\) (La última <em>a</em> hizo \(a \longrightarrow  (e) a\))</p>

<p>\(\Longrightarrow  W[print] (W[**] (e, e) (e))\)  (La última \(a\) hace \(\epsilon\))</p>

<p>\(\overset{*}{\Longrightarrow} W[print] (W[**] (W[g], W[f]) (N[8]))\) (después de aplicar reiteradas veces las reglas)</p>

<p>En forma gráfica, tenemos el árbol sintáctico concreto que sigue:</p>

<p><img src="/assets/images/ast-compose-g-f-8.jpg" alt="" /></p>

<p>Este es el mismo diagrama hecho usando <a href="https://mermaid-js.github.io/mermaid/#/">mermaid</a>:</p>

<div class="mermaid">
graph TD
      E1[e]

subgraph "print(**(g,f)(8))"
      E1--&gt;W1["W (print)"]
      E1--&gt;A1(a);
end    

      A1--&gt;E2["e"]
      A1--&gt;A2["a"]


subgraph "(**(g,f)(8))"
      A1--&gt;LP1["("]

      E2--&gt;W2["W (**)"]
      E2--&gt;A3[a]

      A3--&gt;LP2["("]
      A3--&gt;E3["e"]
      A3--&gt;COMMA1[","]
      A3--&gt;E4["e"]
      A3--&gt;RP2[")"]

      E3--&gt;W3["W (g)]"]
      E3--&gt;A5[a]

      E4--&gt;W4["W (f)]"]
      E4--&gt;A6[a]

      A1--&gt;RP1[")"]

      A5--&gt;EMPTY5[ε]
      A6--&gt;EMPTY6[ε]

subgraph "(g,f)(8)"
      A3--&gt;A4[a]

      A4 --&gt; LP3["("]
      A4 --&gt; E5["e"]
            E5--&gt;NUM["NUMBER (8)"]
      A4 --&gt; RP3[")"]
      A4 --&gt; A7["a"]


      A7--&gt;EMPTY2[ε]


end

    end

 
      A2--&gt;EMPTY[ε]


</div>

<h2 id="lenguaje">Lenguaje Generado por Una Gramática</h2>

<p>Para cada variable sintáctica
\(A \in V\) el lenguaje
generado desde la variable \(A\) se define como:</p>

\[L_A(G) = \{ x \in \Sigma^* : A \stackrel{*}{\Longrightarrow} x \}\]

<p>Esto es, \(L_A(G)\) es el conjunto de frases del alfabeto que <strong>derivan</strong> en varias substituciones desde la variable \(A\).</p>

<p>En los métodos de Análisis Sintáctico Descendente Recursivo (PDR) se asocia una subrutina con cada variable sintáctica
\(A \in V\).</p>

<p>La función de dicha subrutina (que de ahora en adelante llamaremos <code class="language-plaintext highlighter-rouge">parseA()</code>) es reconocer \(L_A(G)\).</p>

<p>Siguiendo con el ejemplo de Egg, en \(L_{apply}(EggGrammar)\) tenemos frases como:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">()</code></li>
  <li><code class="language-plaintext highlighter-rouge">(4,b)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(4, +(5,c))</code></li>
  <li><code class="language-plaintext highlighter-rouge">(4,)</code></li>
  <li><code class="language-plaintext highlighter-rouge">/* nada */</code></li>
</ul>

<p>Recuerda que:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apply: /* vacio */ 
     | '(' (expression ',')* expression? ')' apply
</code></pre></div></div>

<p>y que:</p>

\[L_{apply}(EggGrammar) = \{ x \in \Sigma^* : apply \stackrel{*}{\Longrightarrow} x \}\]

<p>Escribiremos una función <code class="language-plaintext highlighter-rouge">parseApply</code>que se deberá encargar de reconocer las frases de \(L_{apply}(EggGrammar)\).</p>

<p>Por supuesto también escribiremos una función <code class="language-plaintext highlighter-rouge">parseExpression</code>que se deberá encargar de reconocer las frases de \(L_{expression}(EggGrammar)\).</p>

<h2 id="funpervar">Una función por Variable Sintáctica</h2>

<p>Repetimos: Cuando construimos un PDR</p>

<ol>
  <li>Se escribe una rutina <code class="language-plaintext highlighter-rouge">parseA</code> por cada variable sintáctica en la gramática \(A \in V\)</li>
  <li>La función de <code class="language-plaintext highlighter-rouge">parseA()</code> es reconocer las frases \(x \in L(A)\) en el lenguaje generado por \(A\) y construir el Arbol de Análisis de dichas frases \(x\).</li>
</ol>

<p>La idea es bien simple: Si, por ejemplo \(A\) tiene una sola regla \(A \Rightarrow B \, C\) 
entonces el código de <code class="language-plaintext highlighter-rouge">parseA()</code> sería tan simple como llamar primero a <code class="language-plaintext highlighter-rouge">parseB()</code>
y luego a <code class="language-plaintext highlighter-rouge">parseC()</code>.</p>

<p>Por ejemplo, en Egg, para hacer el parser escribimos dos funciones</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">parseExpression</code> y</li>
  <li><code class="language-plaintext highlighter-rouge">parseApply</code>.</li>
</ul>

<p>La función <code class="language-plaintext highlighter-rouge">parseExpression</code> reconoce el lenguaje</p>

\[L(expression) = \{ x \in \Sigma^* : expression \stackrel{*}{\Longrightarrow} x \}\]

<p>y la función  <code class="language-plaintext highlighter-rouge">parseApply</code> reconoce el lenguaje</p>

\[L(apply) = \{ x \in \Sigma^* : apply \stackrel{*}{\Longrightarrow} x \}\]

<h2 id="lookahead">El Token de Predicción</h2>

<p>En un PDR, la estrategia general que sigue la rutina <code class="language-plaintext highlighter-rouge">parseA</code> para reconocer \(L(A)\) es
decidir en términos del terminal <code class="language-plaintext highlighter-rouge">a</code> por el que vamos en la entrada cual de las partes derechas \(\alpha_i\) de las reglas de \(A\)</p>

\[A \rightarrow \alpha_1\]

\[A \rightarrow \alpha_2\]

\[\ldots\]

\[A \rightarrow \alpha_n\]

<p>se aplica para construir el árbol. Si es así, a continuación se pasa a comprobar que la entrada que sigue a continuación de <code class="language-plaintext highlighter-rouge">a...</code> pertenece al lenguaje generado por \(\alpha_i\).</p>

<p>Por ejemplo, en la gramática de Egg estas son las reglas para <code class="language-plaintext highlighter-rouge">expression</code>:</p>

<pre><code class="language-yacc">expression: STRING
          | NUMBER
          | WORD apply
</code></pre>

<p>Vemos que las tres reglas empiezan por un token distinto. Si sabemos que el token actual es <code class="language-plaintext highlighter-rouge">STRING</code> la regla para seguir será la primera y si es 
<code class="language-plaintext highlighter-rouge">WORD</code> estamos seguros que la regla que se aplica es la tercera.</p>

<h2 id="calculando-por-donde-empiezan-las-derivaciones">Calculando por donde empiezan las derivaciones</h2>

<p>En un analizador predictivo descendente recursivo (PDR o APDR) se
asume que el terminal/token que actualmente esta siendo observado (que a partir de ahora denominaré <code class="language-plaintext highlighter-rouge">lookahead</code>) permite determinar unívocamente que producción de \(A\) hay
que aplicar.</p>

<p>Una vez que dentro del cuerpo de  <code class="language-plaintext highlighter-rouge">parseA</code> se ha determinado que la regla concreta por la que 
continuar la derivación es la regla \(A \rightarrow \alpha\), el algoritmo procede a reconocer
\(L_{\alpha}(G)\), el lenguaje generado por la parte derecha de la regla: \(\alpha\):</p>

\[L_{\alpha}(G) = \{ x \in \Sigma^* : \alpha \stackrel{*}{\Longrightarrow} x \}\]

<p>Para ello se procede así. Supongamos que \(\alpha = X_1 \ldots X_n\), donde \(X_i\) es o bien un token \(X_i \in \Sigma\) o bien una variable \(X_i \in V\).</p>

<ul>
  <li>
    <p>las apariciones de terminales \(X_i\) en \(\alpha\) son emparejadas con los terminales en la entrada avanzando en el flujo de tokens,</p>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">lookahead</span> <span class="o">=</span> <span class="nx">lex</span><span class="p">();</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>mientras que</p>

<ul>
  <li>las apariciones de variables sintácticas \(X_i = B \in V\) en \(\alpha\) se traducen en llamadas a la correspondiente subrutina asociada con <code class="language-plaintext highlighter-rouge">parseB</code>.</li>
</ul>

<p>La secuencia de llamadas cuando se procesa la entrada mediante el
siguiente programa construye “implícitamente” el árbol de análisis
sintáctico concreto.</p>

<h2 id="first">Los Conjuntos FIRST</h2>

<p>El análisis predictivo confía en que, si
estamos ejecutando la entrada del procedimiento <code class="language-plaintext highlighter-rouge">parseA</code>, el cuál está
asociado con la variable \(A \in V\), el símbolo terminal <code class="language-plaintext highlighter-rouge">a</code> que esta en la
entrada  determine de manera unívoca cual de las reglas de producción
\(A \rightarrow \alpha_i\) debe ser procesada.</p>

<p>Si se piensa, esta condición se puede satisfacer si se cumple que:</p>

<p>Para toda variable \(A\), las derivaciones de las partes derechas
\(\alpha_i\) de sus reglas \(A \rightarrow \alpha_i\)  “<em>comienzan</em>” por diferentes tokens.</p>

<p>Supongamos que \(\alpha \in (V \cup \Sigma)*\) es una frase de variables y terminales. Denotaremos por  \(FIRST(\alpha)\) al conjunto de terminales que pueden aparecer al “comienzo” de una derivación desde \(\alpha\):</p>

\[FIRST(\alpha) = \left \{ b \in \Sigma :  \alpha  \stackrel{*}{\Longrightarrow}  b \beta \right \}\]

<h2 id="pseudocódigo-de-la-función-de-parsing">Pseudocódigo de la Función de Parsing</h2>

<p>Podemos reformular ahora nuestra afirmación anterior en estos términos:</p>

<p>Si</p>

<ol>
  <li>\(A \rightarrow \gamma_1 \mid \ldots \mid \gamma_n\) 
son todas las reglas de producción de la variable \(A\) y</li>
  <li>los conjuntos \(FIRST(\gamma_i)\) son disjuntos,</li>
</ol>

<p>entonces podemos construir la función 
<code class="language-plaintext highlighter-rouge">parseA</code> para reconocer el lenguaje generado por la variable \(A\) siguiendo este seudocódigo:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="nx">parseA</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">lookahead</span> <span class="k">in</span> <span class="nx">FIRST</span><span class="p">(</span><span class="nx">gamma_1</span><span class="p">))</span> <span class="p">{</span> <span class="nx">codigo</span> <span class="nx">gamma_1</span> <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">lookahead</span> <span class="k">in</span> <span class="nx">FIRST</span><span class="p">(</span><span class="nx">gamma_2</span><span class="p">))</span> <span class="p">{</span> <span class="nx">codigo</span> <span class="nx">gamma_2</span> <span class="p">}</span>
      <span class="p">...</span>
      <span class="k">else</span> <span class="p">(</span><span class="nx">lookahead</span> <span class="k">in</span> <span class="nx">FIRST</span><span class="p">(</span><span class="nx">gamma_n</span><span class="p">))</span> <span class="p">{</span> <span class="nx">codigo</span> <span class="nx">gamma_n</span> <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>Donde si \(\gamma_j\) es \(X_1 \ldots X_k\) el código <code class="language-plaintext highlighter-rouge">gamma_j</code> consiste en
una secuencia \(i = 1 \ldots k\) de uno de estos dos tipos de código:</p>

<ul>
  <li>
    <p>Llamar a la subrutina <code class="language-plaintext highlighter-rouge">parseX_i()</code> si \(X_i\) es una variable sintáctica</p>
  </li>
  <li>
    <p>Hacer una llamada al analizador léxico  avanzando sobre el token <code class="language-plaintext highlighter-rouge">lex()</code> si \(X_i\) es el terminal actual</p>
  </li>
</ul>

<p>Si aplicamos esta teoría a la variable sintáctica <code class="language-plaintext highlighter-rouge">expression</code> cuyas reglas eran:</p>

<pre><code class="language-yacc">expression: STRING
          | NUMBER
          | WORD apply
</code></pre>

<p>tenemos tres partes derechas \(\gamma_1\) = <code class="language-plaintext highlighter-rouge">STRING</code>,  \(\gamma_2\) = <code class="language-plaintext highlighter-rouge">NUMBER</code> y \(\gamma_3\) = <code class="language-plaintext highlighter-rouge">WORD apply</code>. Si computamos los \(FIRST(\gamma_i)\) obtenemos:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FIRST(STRING)     = { STRING }
FIRST(NUMBER)     = { NUMBER }
FIRST(WORD apply) = { WORD }
</code></pre></div></div>

<p>nos produce este código:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">parseExpression</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">lookahead</span><span class="p">.</span><span class="nx">type</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">STRING</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">lex</span><span class="p">();</span> <span class="c1">// Saltamos el token STRING</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">lookahead</span><span class="p">.</span><span class="nx">type</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">NUMBER</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
     <span class="nx">lex</span><span class="p">();</span>  <span class="c1">// Saltemos el token NUMBER</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">lookahead</span><span class="p">.</span><span class="nx">type</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">WORD</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">lex</span><span class="p">();</span> <span class="c1">// Consumimos  WORD</span>
    <span class="k">return</span> <span class="nx">parseApply</span><span class="p">();</span> <span class="c1">// ... y llamamos a parseApply</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nx">SyntaxError</span><span class="p">(</span><span class="s2">`Unexpected syntax line </span><span class="p">${</span><span class="nx">lineno</span><span class="p">}</span><span class="s2">: </span><span class="p">${</span><span class="nx">program</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)}</span><span class="s2">`</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="que-hacer-cuando-aparecen-reglas-vacías">Que hacer cuando aparecen reglas vacías</h2>

<p>Aplicar el algoritmo PDR a las dos reglas de <code class="language-plaintext highlighter-rouge">apply</code> requiere añadir algunas extensiones al método.</p>

<p>Recordemos las reglas de <code class="language-plaintext highlighter-rouge">apply</code>:</p>

<pre><code class="language-yacc">apply: /* vacio */
     | '(' (expression ',')* expression? ')' apply
</code></pre>

<p>Parece que si el <code class="language-plaintext highlighter-rouge">lookahead</code>es un <code class="language-plaintext highlighter-rouge">'('</code>  la regla que se aplica
es la segunda.</p>

<p>Mas difícil es determinar que tokens pueden aparecer cuando en la derivación se aplica la regla <code class="language-plaintext highlighter-rouge">apply: /* vacio */</code>.</p>

<p>Para poder responder a esta pregunta consideremos una derivación en la que intervenga la regla <code class="language-plaintext highlighter-rouge">apply: /* vacio */</code></p>

<p>Si hacemos una derivación a derechas en la que esta es la última regla que se aplica, tendría que ocurrir algo como esto. Si derivamos desde el símbolo de arranque \(expression\):</p>

\[expression \stackrel{*}{\Longrightarrow} \beta \, apply \, a_1\, a_2\, \ldots \, a_n\]

<p>en algún moomento en la parte derecha aparece <em>apply</em> quizá precedido de alguna secuencia \(\beta\),
donde \(\beta\) es una cadena arbitraria de variables y terminales y los \(a_i \in \Sigma\) son terminales.  Si derivamos por \(apply \longrightarrow \epsilon\) tenemos:</p>

\[\Rightarrow \beta \, a_1 \ldots \, a_n\]

<p>Se sigue de la derivación anterior que cuando se aplica la regla <code class="language-plaintext highlighter-rouge">apply: /* vacio */</code>
cualquier token que, como es el caso del token \(a_1\), pueda aparecer en alguna derivación <strong>inmediatamente a continuación de <code class="language-plaintext highlighter-rouge">apply</code></strong> 
es un posible <code class="language-plaintext highlighter-rouge">lookahead</code> en la ejecución de  <code class="language-plaintext highlighter-rouge">parseApply()</code>.</p>

<h2 id="cálculo-del-follow">Cálculo del FOLLOW</h2>

<p>Tenemos entonces que computar el conjunto de tokens <code class="language-plaintext highlighter-rouge">FOLLOW(apply)</code>  que pueden aparecer a continuación de la variable<code class="language-plaintext highlighter-rouge">apply</code> en alguna derivación desde <code class="language-plaintext highlighter-rouge">expression</code>.</p>

<p>\(FOLLOW(apply) = \left \{ a \in \Sigma :  expression  \stackrel{*}{\Longrightarrow}  \beta \, apply \, a \, \alpha  \right \}\) where \(\alpha \in (V \cup \Sigma)^*\)</p>

<p>Consideremos la siguiente sinopsis de  derivación de una cadena como</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">print</span><span class="p">(</span><span class="dl">"</span><span class="s2">hi</span><span class="dl">"</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
</code></pre></div></div>
<p>en la que el símbolo \(\bullet\) denota el final de la cadena de entrada:</p>

\[expression \bullet \Rightarrow WORD \, apply \bullet\]

<p>que deriva en:</p>

\[\Longrightarrow WORD \, ( \,expression \, , \, expression \, ) \, apply \bullet\]

<p>que aplicando la regla \(apply \longrightarrow \epsilon\) deriva en:</p>

\[\Longrightarrow WORD \, ( \,expression \, , \, expression \, ) \bullet\]

<p>Ya de aquí sacamos la conclusión de que el token final de la entrada está en los  “follow” de <em>apply</em>:</p>

<p>\(\bullet \in  FOLLOW(apply)\).</p>

<p>Así pues en el instante de la ejecución del análisis que se corresponde con ese punto de esta derivación se llamará  a <code class="language-plaintext highlighter-rouge">parseApply()</code> y el valor de <em>lookahead</em> será el final de la entrada, que hemos denotado como \(\bullet\) (y que en nuestro analizador léxico se retorna como <code class="language-plaintext highlighter-rouge">null</code>).</p>

<p>Sigamos derivando:</p>

\[\stackrel{*}{\Longrightarrow} WORD \, ( \,expression \, , \, WORD \, apply \, ) \bullet\]

<p>aplicando la regla \(expression \longrightarrow STRING\), tenemos:</p>

\[\Longrightarrow WORD \, ( \, STRING \, , \, WORD \, apply \, ) \bullet\]

<p>que aplicando la regla \(apply \longrightarrow \epsilon\) deriva en:</p>

\[\stackrel{*}{\Longrightarrow} WORD \, ( \, STRING \, , \, WORD) \bullet\]

<p>muestra claramente que el tokens es <code class="language-plaintext highlighter-rouge">')'</code> está en los “follow” de <em>apply</em>:</p>

<p>\(')' \in  FOLLOW(apply)\).</p>

<figure class="">
  <img src="/assets/images/egg-syntax-tree-4-W-LP-S-comma-W-RP-EOI.jpg" alt="" /><figcaption>
      Syntax Tree for <code class="language-plaintext highlighter-rouge">print("hi", a)</code>

    </figcaption></figure>

<p>También si nos fijamos en esta otra derivación para una frase como <code class="language-plaintext highlighter-rouge">'x'</code>:</p>

\[expression \bullet \Rightarrow WORD \, apply \bullet \Longrightarrow WORD \, \bullet\]

<p>vemos de nuevo que <code class="language-plaintext highlighter-rouge">apply </code> aparece al final de la frase cuando se aplicó la regla de producción 
\(apply \longrightarrow \epsilon\).</p>

<p>Así pues en el instante de la ejecución del análisis que se corresponde con ese punto de esta derivación se llamará  a <code class="language-plaintext highlighter-rouge">parseApply()</code> y el valor de <em>lookahead</em> será el final de la entrada, que hemos denotado como \(\bullet\) (y que en el analizador léxico se retorna como <code class="language-plaintext highlighter-rouge">null</code>).</p>

<p><img src="/assets/images/pdr-egg-apply-empty-end-of-input-follow.png" alt="" /></p>

<p>Asumiremos que el analizador léxico retorna un <code class="language-plaintext highlighter-rouge">null</code> cuando encuentra el final de la entrada.</p>

<p>Otro token que es fácil ver que puede seguir a  <code class="language-plaintext highlighter-rouge">apply</code> es la coma. Se lo dejamos como <strong>Ejercicio</strong>: Busque una derivación en la que la coma aparezca siguiendo a <code class="language-plaintext highlighter-rouge">apply</code></p>

<p>Por tanto el conjunto  de los “follow” de <em>apply</em> son:</p>

<p>la coma “,” el fin de la entrada “\(\bullet\)”  y el paréntesis cerrar”)”</p>

<p>Puesto que la segunda regla tiene un <code class="language-plaintext highlighter-rouge">*</code> indicando la repetición 0 o mas veces de la expresión entre paréntesis:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apply: '(' (expression ',')* expression? ')' apply
</code></pre></div></div>

<p>necesitaremos un bucle para ir procesando la expresión interior. El bucle se termina cuando vemos el paréntesis de cierre o bien si se produce el final de la entrada.</p>

<p>Entonces el código queda como sigue:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">parseApply</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">lookahead</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="c1">// token "End of Input": apply: /* vacio */</span>
  <span class="k">if</span> <span class="p">((</span><span class="nx">lookahead</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">RP</span><span class="dl">"</span><span class="p">)</span><span class="o">||</span> <span class="p">(</span><span class="nx">lookahead</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">COMMA</span><span class="dl">'</span><span class="p">))</span> <span class="c1">// apply: /* vacio */</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">lookahead</span><span class="p">.</span><span class="nx">type</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">LP</span><span class="dl">"</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nx">SyntaxError</span><span class="p">(</span><span class="s2">`Error: Found </span><span class="p">${</span><span class="nx">lookahead</span><span class="p">.</span><span class="nx">type</span><span class="p">}</span><span class="s2">, Expected ',' or '(' or ')'`</span><span class="p">);</span>
  
  <span class="nx">lex</span><span class="p">();</span>                <span class="c1">// apply: '(' (expression ',')* expression? ')' apply</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">lookahead</span> <span class="o">&amp;&amp;</span> <span class="nx">lookahead</span><span class="p">.</span><span class="nx">type</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">RP</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">parseExpression</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">lookahead</span> <span class="o">&amp;&amp;</span> <span class="nx">lookahead</span><span class="p">.</span><span class="nx">type</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">COMMA</span><span class="dl">"</span><span class="p">)</span> <span class="nx">lex</span><span class="p">();</span> 
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">lookahead</span> <span class="o">||</span> <span class="nx">lookahead</span><span class="p">.</span><span class="nx">type</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">RP</span><span class="dl">"</span><span class="p">)</span> 
      <span class="k">throw</span> <span class="k">new</span> <span class="nx">SyntaxError</span><span class="p">(</span><span class="s2">`Error`</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">lookahead</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nx">SyntaxError</span><span class="p">(</span><span class="s2">`Error`</span><span class="p">);</span>
  <span class="nx">lex</span><span class="p">();</span>
  <span class="k">return</span> <span class="nx">parseApply</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Aunque esta versión controla mejor los errores, el código queda mas simple si seguimos
la estrategia de si el token <code class="language-plaintext highlighter-rouge">lookahead</code> es el paréntesis izquierdo 
entonces se trata de la regla de producción del paréntesis y en caso 
contrario es la regla \(apply \longrightarrow \epsilon\):</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">parseApply</span><span class="p">(</span><span class="nx">tree</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">lookahead</span><span class="p">)</span> <span class="k">return</span> <span class="nx">tree</span><span class="p">;</span>   <span class="c1">// apply: /* vacio */</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">lookahead</span><span class="p">.</span><span class="nx">type</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">LP</span><span class="dl">"</span><span class="p">)</span> <span class="k">return</span> <span class="nx">tree</span><span class="p">;</span> <span class="c1">// apply: /* vacio */</span>

  <span class="nx">lex</span><span class="p">();</span>

  <span class="nx">tree</span> <span class="o">=</span> <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">apply</span><span class="dl">'</span><span class="p">,</span> <span class="na">operator</span><span class="p">:</span> <span class="nx">tree</span><span class="p">,</span> <span class="na">args</span><span class="p">:</span> <span class="p">[]};</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">lookahead</span> <span class="o">&amp;&amp;</span> <span class="nx">lookahead</span><span class="p">.</span><span class="nx">type</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">RP</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">arg</span> <span class="o">=</span> <span class="nx">parseExpression</span><span class="p">();</span>
    <span class="nx">tree</span><span class="p">.</span><span class="nx">args</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arg</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">lookahead</span> <span class="o">&amp;&amp;</span> <span class="nx">lookahead</span><span class="p">.</span><span class="nx">type</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">COMMA</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">lex</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">lookahead</span> <span class="o">||</span> <span class="nx">lookahead</span><span class="p">.</span><span class="nx">type</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">RP</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nx">SyntaxError</span><span class="p">(</span><span class="s2">`Expected ',' or ')'  at line </span><span class="p">${</span><span class="nx">lineno</span><span class="p">}</span><span class="s2">: ... </span><span class="p">${</span><span class="nx">program</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">20</span><span class="p">)}</span><span class="s2">`</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">lookahead</span><span class="p">)</span>  <span class="k">throw</span> <span class="k">new</span> <span class="nx">SyntaxError</span><span class="p">(</span><span class="s2">`Expected ')'  at line </span><span class="p">${</span><span class="nx">lineno</span><span class="p">}</span><span class="s2">: ... </span><span class="p">${</span><span class="nx">program</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">20</span><span class="p">)}</span><span class="s2">`</span><span class="p">);</span>
  <span class="nx">lex</span><span class="p">();</span>

  <span class="k">return</span> <span class="nx">parseApply</span><span class="p">(</span><span class="nx">tree</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="ejercicios">Ejercicios</h1>

<ul>
  <li><a href="ejercicio-gramar-egg-inicial">Ejercicios</a></li>
</ul>


        


        

        <br/>
        <br/>
        <br/>

        <script src="https://utteranc.es/client.js"
          repo="ULL-ESIT-GRADOII-PL/ull-esit-gradoii-pl.github.io"
          issue-term="pathname"
          theme="github-light"
          crossorigin="anonymous"
          async>
       </script>

        
 
      </section>

      <footer class="page__meta">
        
        


        
      </footer>
     
      
        <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="whatsapp://send?text=An%C3%A1lisis+Sint%C3%A1ctico+Predictivo+Recursivo%20http%3A%2F%2F0.0.0.0%3A4000%2Fassets%2Ftemas%2Fsyntax-analysis%2Fanalisis-descendente-predictivo-recursivo%2Fpdr-teoria.html" 
  class="btn btn--twitter" 
  style="position: relative; 
  color: #fff; 
  background-color: #5bb66f;
  " 
  onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;"> 
  <i class="fab fa-fw fa-whatsapp" aria-hidden="true">
 </i><span> Whatsapp</span></a>

  <a 
   href="https://twitter.com/intent/tweet?text=An%C3%A1lisis+Sint%C3%A1ctico+Predictivo+Recursivo%20http%3A%2F%2F0.0.0.0%3A4000%2Fassets%2Ftemas%2Fsyntax-analysis%2Fanalisis-descendente-predictivo-recursivo%2Fpdr-teoria.html" 
   class="btn btn--twitter" 
   onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" 
   title="Share on Twitter">
   <i class="fab fa-fw fa-twitter" aria-hidden="true"></i>
   <span> Twitter</span>
  </a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2F0.0.0.0%3A4000%2Fassets%2Ftemas%2Fsyntax-analysis%2Fanalisis-descendente-predictivo-recursivo%2Fpdr-teoria.html" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>


   <a 
    href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2F0.0.0.0%3A4000%2Fassets%2Ftemas%2Fsyntax-analysis%2Fanalisis-descendente-predictivo-recursivo%2Fpdr-teoria.html" 
    class="btn btn--linkedin" 
    onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" 
    title="Share on LinkedIn">
    <i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span>
  </a>
  
</section>

      
         
      

      <section class="page__share">   
     <a href="https://github.com/ULL-ESIT-GRADOII-PL/ull-esit-gradoii-pl.github.io/tree/master//assets/temas/syntax-analysis/analisis-descendente-predictivo-recursivo/pdr-teoria.md" 
        target="_blank" 
        style="background-color: #6f42c1; color: #ffff" 
        class="btn btn--twitter">
        <i class="fab fa-fw fa-github" aria-hidden="true"></i>
        <span>✏️</span>
      </a>
    
</section>
  

    </div>

  </article>

  
  
</div>

<!-- Mathjax Support  -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>


<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>mermaid.initialize({startOnLoad:true});</script>
    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2022  Casiano Rodríguez León. 


  <!--

  Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; 
  <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.
    
  -->
</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>










  </body>
</html>
